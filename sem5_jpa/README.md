### Некоторые замечания по созданию проекта

В файле application.properties добавим пару строк, которые отключат автоматическую генерацию hibernate-ом

```properties
spring.jpa.generate-ddl=false
spring.jpa.hibernate.ddl-auto=none
```

после этого можно задействовать файлы
- `schema.sql`
- `data.sql`  

которые будут автоматически прочитаны СПРИНГом и скрипты из них запущены
```
CREATE TABLE IF NOT EXISTS tasks (
id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
description VARCHAR(255) NOT NULL,
status VARCHAR(15) NOT NULL,
create_time TIMESTAMP NOT NULL
);

INSERT INTO tasks (description, status, create_time)
VALUES
('покупки: хлеб, кефир, бананы, рыба', 'NOT_STARTED', '2024-04-20 15:30:45.000'),
("фильмы к просмотру: Жанна дАрк, Сплит, Монстры на каникулах", 'IN_PROGRESS', '2024-01-15 22:01:32.000'),
('шиномонтаж', 'COMPLETED', '2024-04-02 12:40:15.000'),
("купить подарок", 'IN_PROGRESS', '2024-04-21 22:01:32.000'),
("корм для кошки", 'NOT_STARTED', '2024-04-24 18:32:18.000');

```

> JSON, который пересылается от браузера на сервер и обратно имеет наименования полей
НЕ КАК В ТАБЛИЦЕ, а КАК в ОБЪЕКТЕ


## ИСКЛЮЧЕНИЯ В SPRING

В Spring, когда исключение выбрасывается внутри транзакционного метода сервиса, транзакция обычно
откатывается, и это исключение распространяется вверх по стеку вызовов, пока не встретит
обработчик исключений.

1. Откат транзакции: При выбрасывании исключения внутри метода сервиса, помеченного аннотацией
   @Transactional, Spring обычно откатывает текущую транзакцию, чтобы сохранить целостность
   данных в базе данных.

2. Передача исключения: Исключение будет передано выше по стеку вызовов, пока не будет обработано.
   Если исключение не будет обработано в самом методе, где оно было выброшено, оно будет передано
   выше по стеку вызовов до тех пор, пока не найдется обработчик исключений.

3. Ответ пользователю: Пользователь, который отправил запрос, узнает об ошибке, если ваше приложение
   обрабатывает исключение и отправляет соответствующий ответ. Обычно это делается с помощью механизмов
   обработки исключений, таких как @ExceptionHandler в Spring MVC. Если исключение не будет обработано,
   пользователь может получить стандартное сообщение об ошибке HTTP 500.

Чтобы обеспечить более удобный и информативный опыт для пользователя, вы можете создать обработчики
исключений, которые преобразуют выброшенные исключения в понятные для пользователя сообщения об
ошибках и отправляют их обратно клиенту. Например, вы можете использовать аспекты для перехвата
исключений в Spring и отправки соответствующего ответа пользователю.

------------------------------

# ENTITY класс
## Работа с ENUM 

Если поле класса, по которому будет построена таблица, содержит перечисление (enum),
то значения этого перечисления будут отображены в таблице базы данных как строки.
В базе данных будет храниться строковое представление каждого значения перечисления.

Аннотация @Enumerated – принимает параметр типа EnumType:

1. EnumType.STRING – это значит, что в базе будет хранится имя этого enum.
   То есть если мы зададим role = RoleEnum.ADMIN, то в БД в поле role будет хранится значение ADMIN.

2. EnumType.ORDINAL – это значит, что в базе будет хранится ID этого enum. ID –
   это место расположение в списке перечисления начиная с 0.
   Например, если значение enum равно ADMIN, то в базе будет хранится число 2,
   а если будет ANONYMOUS, то в базе будет хранится 0.
   */

## ID

В вашем классе Task вы используете аннотацию `@GeneratedValue(strategy = GenerationType.AUTO)`,
что предполагает автоматическую генерацию значений для поля id. Однако база данных H2 не может
найти последовательность для генерации этих значений.

Решение этой проблемы зависит от вашего контекста приложения:

Создайте последовательность в базе данных H2: Вы можете создать последовательность вручную
в вашей базе данных H2. Например, для H2 вы можете выполнить следующую команду SQL:

```
CREATE SEQUENCE TASKS_SEQ START WITH 1 INCREMENT BY 1;
```

Измените стратегию генерации ID: Вы можете изменить стратегию генерации ID в вашем классе Task,
чтобы она не использовала последовательность. Например, вы можете использовать `GenerationType.IDENTITY`:

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
private long id;
```

Это позволит базе данных генерировать ID автоматически без использования последовательности.
